<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API reference · DFTK.jl</title><link rel="canonical" href="https://juliamolsim.github.io/DFTK.jl/stable/api/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="DFTK.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">DFTK.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Getting started</span><ul><li><a class="tocitem" href="../guide/installation/">Installation</a></li><li><a class="tocitem" href="../guide/tutorial/">Tutorial</a></li><li><a class="tocitem" href="../guide/parallelisation/">Timings and parallelisation</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/metallic_systems/">Temperature and metallic systems</a></li><li><a class="tocitem" href="../examples/pymatgen/">Creating supercells with pymatgen</a></li><li><a class="tocitem" href="../examples/ase/">Creating slabs with ASE</a></li><li><a class="tocitem" href="../examples/geometry_optimization/">Geometry optimization</a></li><li><a class="tocitem" href="../examples/gross_pitaevskii/">Gross-Pitaevskii equation in one dimension</a></li><li><a class="tocitem" href="../examples/gross_pitaevskii_2D/">Gross-Pitaevskii equation with magnetism</a></li><li><a class="tocitem" href="../examples/cohen_bergstresser/">Cohen-Bergstresser model</a></li><li><a class="tocitem" href="../examples/arbitrary_floattype/">Arbitrary floating-point types</a></li><li><a class="tocitem" href="../examples/scf_callbacks/">Monitoring self-consistent field calculations</a></li><li><a class="tocitem" href="../examples/custom_solvers/">Custom solvers</a></li><li><a class="tocitem" href="../examples/custom_potential/">Custom potential</a></li></ul></li><li><span class="tocitem">Advanced topics</span><ul><li><a class="tocitem" href="../advanced/conventions/">Notation and conventions</a></li><li><a class="tocitem" href="../advanced/data_structures/">Data structures</a></li><li><a class="tocitem" href="../advanced/useful_formulas/">Useful formulas</a></li><li><a class="tocitem" href="../advanced/symmetries/">Crystal symmetries</a></li></ul></li><li class="is-active"><a class="tocitem" href>API reference</a></li><li><a class="tocitem" href="../publications/">Publications</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaMolSim/DFTK.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-reference"><a class="docs-heading-anchor" href="#API-reference">API reference</a><a id="API-reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-reference" title="Permalink"></a></h1><p>This page provides a plain list of all documented functions, structs, modules and macros in DFTK. Note that this list is neither structured, complete nor particularly clean, so it only provides rough orientation at the moment. The best reference is the code itself.</p><article class="docstring"><header><a class="docstring-binding" id="DFTK.DFTK" href="#DFTK.DFTK"><code>DFTK.DFTK</code></a> — <span class="docstring-category">Module</span></header><section><div><p>DFTK –- The density-functional toolkit. Provides functionality for experimenting with plane-wave density-functional theory algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/DFTK.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.DFTK_DATADIR" href="#DFTK.DFTK_DATADIR"><code>DFTK.DFTK_DATADIR</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>The default search location for Pseudopotential data files</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/common/constants.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.timer" href="#DFTK.timer"><code>DFTK.timer</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>TimerOutput object used to store DFTK timings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/common/timer.jl#L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.AtomicLocal" href="#DFTK.AtomicLocal"><code>DFTK.AtomicLocal</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Atomic local potential defined by <code>model.atoms</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/terms/local.jl#L65-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.AtomicNonlocal" href="#DFTK.AtomicNonlocal"><code>DFTK.AtomicNonlocal</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Nonlocal term coming from norm-conserving pseudopotentials in Kleinmann-Bylander form. <span>$\text{Energy} = \sum_a \sum_{ij} \sum_{n} f_n &lt;ψ_n|p_{ai}&gt; D_{ij} &lt;p_{aj}|ψ_n&gt;.$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/terms/nonlocal.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.DensityDerivatives-Tuple{Any,Integer,RealFourierArray}" href="#DFTK.DensityDerivatives-Tuple{Any,Integer,RealFourierArray}"><code>DFTK.DensityDerivatives</code></a> — <span class="docstring-category">Method</span></header><section><div><p>DOCME compute density in real space and its derivatives starting from ρ</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/terms/xc.jl#L180-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.ElementCohenBergstresser-Tuple{Any}" href="#DFTK.ElementCohenBergstresser-Tuple{Any}"><code>DFTK.ElementCohenBergstresser</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Element where the interaction with electrons is modelled as in <a href="DOI 10.1103/PhysRev.141.789">CohenBergstresser1966</a>. Only the homonuclear lattices of the diamond structure are implemented (i.e. Si, Ge, Sn).</p><p><code>key</code> may be an element symbol (like <code>:Si</code>), an atomic number (e.g. <code>14</code>) or an element name (e.g. <code>&quot;silicon&quot;</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/elements.jl#L95-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.ElementCoulomb-Tuple{Any}" href="#DFTK.ElementCoulomb-Tuple{Any}"><code>DFTK.ElementCoulomb</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Element interacting with electrons via a bare Coulomb potential (for all-electron calculations) <code>key</code> may be an element symbol (like <code>:Si</code>), an atomic number (e.g. <code>14</code>) or an element name (e.g. <code>&quot;silicon&quot;</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/elements.jl#L40-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.ElementPsp-Tuple{Any}" href="#DFTK.ElementPsp-Tuple{Any}"><code>DFTK.ElementPsp</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Element interacting with electrons via a pseudopotential model. <code>key</code> may be an element symbol (like <code>:Si</code>), an atomic number (e.g. <code>14</code>) or an element name (e.g. <code>&quot;silicon&quot;</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/elements.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.Energies" href="#DFTK.Energies"><code>DFTK.Energies</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A simple struct to contain a vector of energies, and utilities to print them in a nice format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/energies.jl#L2-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.Entropy" href="#DFTK.Entropy"><code>DFTK.Entropy</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Entropy term -TS, where S is the electronic entropy. Turns the energy E into the free energy F=E-TS. This is in particular useful because the free energy, not the energy, is minimized at self-consistency.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/terms/entropy.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.EtsfFolder-Tuple{AbstractString}" href="#DFTK.EtsfFolder-Tuple{AbstractString}"><code>DFTK.EtsfFolder</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Initialize a EtsfFolder from the path to the folder which contains the data in the ETSF Nanoquanta format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/external/etsf_nanoquanta.jl#L15-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.Ewald" href="#DFTK.Ewald"><code>DFTK.Ewald</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Ewald term: electrostatic energy per unit cell of the array of point charges defined by <code>model.atoms</code> in a uniform background of compensating charge yielding net neutrality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/terms/ewald.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.ExternalFromFourier" href="#DFTK.ExternalFromFourier"><code>DFTK.ExternalFromFourier</code></a> — <span class="docstring-category">Type</span></header><section><div><p>External potential from the (unnormalized) Fourier coefficients <code>V(G)</code> G is passed in cartesian coordinates</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/terms/local.jl#L41-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.ExternalFromReal" href="#DFTK.ExternalFromReal"><code>DFTK.ExternalFromReal</code></a> — <span class="docstring-category">Type</span></header><section><div><p>External potential from an analytic function <code>V</code> (in cartesian coordinates). No low-pass filtering is performed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/terms/local.jl#L28-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.FourierMultiplication" href="#DFTK.FourierMultiplication"><code>DFTK.FourierMultiplication</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Fourier space multiplication, like a kinetic energy term: (Hψ)(G) = multiplier(G) ψ(G)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/terms/operators.jl#L80-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.Hartree" href="#DFTK.Hartree"><code>DFTK.Hartree</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Hartree term: for a decaying potential V the energy would be</p><p>1/2 ∫ρ(x)ρ(y)V(x-y) dxdy</p><p>with the integral on x in the unit cell and of y in the whole space. For the Coulomb potential with periodic boundary conditions, this is rather</p><p>1/2 ∫ρ(x)ρ(y) G(x-y) dx dy</p><p>where G is the Green&#39;s function of the periodic Laplacian with zero mean (-Δ G = sum<em>{R} 4π δ</em>R, integral of G zero on a unit cell).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/terms/hartree.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.HybridMixing" href="#DFTK.HybridMixing"><code>DFTK.HybridMixing</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The model for the susceptibility is</p><div>\[\begin{align*}
χ_0(r, r&#39;) &amp;= (-LDOS(εF, r) δ(r, r&#39;) + LDOS(εF, r) LDOS(εF, r&#39;) / DOS(εF)) \\
           &amp;+ \sqrt{L(x)} IFFT \frac{C_0 G^2}{4π (1 - C_0 G^2 / k_{TF}^2)} FFT \sqrt{L(x)}
\end{align*}\]</div><p>where <span>$C_0 = 1 - ε_r$</span> and the same convention for parameters is used as in <code>RestaMixing</code>. Additionally there is the real-space localisation function <code>L(r)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.KerkerMixing" href="#DFTK.KerkerMixing"><code>DFTK.KerkerMixing</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Kerker mixing: <span>$J^{-1} ≈ \frac{α G^2}{k_{TF}^2 + G^2}$</span> where <span>$k_{TF}$</span> is the Thomas-Fermi wave vector.</p><p>Notes:</p><ul><li>Abinit calls <span>$1/k_{TF}$</span> the dielectric screening length (parameter <em>dielng</em>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.Kinetic" href="#DFTK.Kinetic"><code>DFTK.Kinetic</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Kinetic energy: 1/2 sum<em>n f</em>n ∫ |∇ψn|^2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/terms/kinetic.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.Kpoint" href="#DFTK.Kpoint"><code>DFTK.Kpoint</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Discretization information for kpoint-dependent quantities such as orbitals. More generally, a kpoint is a block of the Hamiltonian; eg collinear spin is treated by doubling the number of kpoints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/PlaneWaveBasis.jl#L9-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.Magnetic" href="#DFTK.Magnetic"><code>DFTK.Magnetic</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Magnetic term <span>$A⋅(-i∇)$</span>. It is assumed (but not checked) that <span>$∇⋅A = 0$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/terms/magnetic.jl#L4-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.MagneticFieldOperator" href="#DFTK.MagneticFieldOperator"><code>DFTK.MagneticFieldOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Magnetic field operator A⋅(-i∇).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/terms/operators.jl#L111-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.Model-Union{Tuple{AbstractArray{T,2}}, Tuple{T}} where T&lt;:Real" href="#DFTK.Model-Union{Tuple{AbstractArray{T,2}}, Tuple{T}} where T&lt;:Real"><code>DFTK.Model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Model(lattice; n_electrons, atoms, terms, temperature,
               smearing, spin_polarization, symmetry)</code></pre><p>Creates the physical specification of a model (without any discretization information).</p><p><code>n_electrons</code> is taken from <code>atoms</code> if not specified</p><p><code>spin_polarization</code> is :none by default (paired electrons)</p><p><code>smearing</code> is Fermi-Dirac if <code>temperature</code> is non-zero, none otherwise</p><p>The <code>symmetry</code> kwarg can be:</p><ul><li>auto: determine from terms if they respect the symmetry of the lattice/atoms.</li><li>off: no symmetries at all</li><li>force: force all the symmetries of the lattice/atoms.</li></ul><p>Careful that in this last case, wrong results can occur if the external potential breaks symmetries (this is not checked).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/Model.jl#L48-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.NonlocalOperator" href="#DFTK.NonlocalOperator"><code>DFTK.NonlocalOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Nonlocal operator in Fourier space in Kleinman-Bylander format, defined by its projectors P matrix and coupling terms D: Hψ = PDP&#39; ψ</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/terms/operators.jl#L94-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.NoopOperator" href="#DFTK.NoopOperator"><code>DFTK.NoopOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Noop operation: don&#39;t do anything. Useful for energy terms that don&#39;t depend on the orbitals at all (eg nuclei-nuclei interaction).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/terms/operators.jl#L33-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.NoopTerm" href="#DFTK.NoopTerm"><code>DFTK.NoopTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A term with a constant zero energy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/terms/terms.jl#L21-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.PlaneWaveBasis" href="#DFTK.PlaneWaveBasis"><code>DFTK.PlaneWaveBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A plane-wave discretized <code>Model</code>. Normalization conventions:</p><ul><li>Things that are expressed in the G basis are normalized so that if <span>$x$</span> is the vector, then the actual function is <span>$sum_G x_G e_G$</span> with <span>$e_G(x) = e^{iG x}/sqrt(unit_cell_volume)$</span>. This is so that, eg <span>$norm(ψ) = 1$</span> gives the correct normalization. This also holds for the density and the potentials.</li><li>Quantities expressed on the real-space grid are in actual values.</li></ul><p><code>G_to_r</code> and <code>r_to_G</code> convert between these representations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/PlaneWaveBasis.jl#L32-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.PlaneWaveBasis" href="#DFTK.PlaneWaveBasis"><code>DFTK.PlaneWaveBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Creates a new basis identical to <code>basis</code>, but with a different set of kpoints</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/PlaneWaveBasis.jl#L178-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.PlaneWaveBasis-Tuple{Model,Number}" href="#DFTK.PlaneWaveBasis-Tuple{Model,Number}"><code>DFTK.PlaneWaveBasis</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Creates a <code>PlaneWaveBasis</code> using the kinetic energy cutoff <code>Ecut</code> and a Monkhorst-Pack kpoint grid. The MP grid can either be specified directly with <code>kgrid</code> providing the number of points in each dimension and <code>kshift</code> the shift (0 or 1/2 in each direction). If not specified a grid is generated using <code>kgrid_size_from_minimal_spacing</code> with a minimal spacing of <code>2π * 0.022</code> per Bohr.</p><p>If <code>use_symmetry</code> is <code>true</code> (default) the symmetries of the crystal are used to reduce the number of <span>$k$</span>-Points which are treated explicitly. In this case all guess densities and potential functions must agree with the crystal symmetries or the result is undefined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/PlaneWaveBasis.jl#L188-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.PlaneWaveBasis-Tuple{PlaneWaveBasis}" href="#DFTK.PlaneWaveBasis-Tuple{PlaneWaveBasis}"><code>DFTK.PlaneWaveBasis</code></a> — <span class="docstring-category">Method</span></header><section><div><p>&quot; Convert a <code>basis</code> into one that uses or doesn&#39;t use BZ symmetrization Mainly useful for debug purposes (e.g. in cases we don&#39;t want to bother with symmetry)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/PlaneWaveBasis.jl#L374-L379">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.PowerNonlinearity" href="#DFTK.PowerNonlinearity"><code>DFTK.PowerNonlinearity</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Power nonlinearity, with energy C ∫ρ^α.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/terms/power_nonlinearity.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.PreconditionerNone" href="#DFTK.PreconditionerNone"><code>DFTK.PreconditionerNone</code></a> — <span class="docstring-category">Type</span></header><section><div><p>No preconditioning</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/eigen/preconditioners.jl#L16-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.PreconditionerTPA" href="#DFTK.PreconditionerTPA"><code>DFTK.PreconditionerTPA</code></a> — <span class="docstring-category">Type</span></header><section><div><p>(simplified version of) Tetter-Payne-Allan preconditioning ↑ M.P. Teter, M.C. Payne and D.C. Allan, Phys. Rev. B 40, 12255 (1989).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/eigen/preconditioners.jl#L27-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.PspCorrection" href="#DFTK.PspCorrection"><code>DFTK.PspCorrection</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Pseudopotential correction energy. TODO discuss the need for this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/terms/psp_correction.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.PspHgh-Union{Tuple{T}, Tuple{Any,Any,Any,Any,Array{Array{T,2},1}}} where T" href="#DFTK.PspHgh-Union{Tuple{T}, Tuple{Any,Any,Any,Any,Array{Array{T,2},1}}} where T"><code>DFTK.PspHgh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">PspHgh(Zion::Number, rloc::Number, cloc::Vector, rp::Vector, h::Vector;
       identifier=&quot;&quot;, description=&quot;&quot;)</code></pre><p>Construct a Hartwigsen, Goedecker, Teter, Hutter separable dual-space Gaussian pseudopotential (1998). The required parameters are the ionic charge <code>Zion</code> (total charge - valence electrons), the range for the local Gaussian charge distribution <code>rloc</code>, the coefficients for the local part <code>cloc</code>, the projector radius <code>rp</code> (one per AM channel) and the non-local coupling coefficients between the projectors <code>h</code> (one matrix per AM channel).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/pseudo/PspHgh.jl#L19-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.RealFourierArray" href="#DFTK.RealFourierArray"><code>DFTK.RealFourierArray</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A structure to facilitate manipulations of an array of real-space type T, in both real and fourier space. Create with <code>from_real</code> or <code>from_fourier</code>, and access with <code>A.real</code> and <code>A.fourier</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/RealFourierArray.jl#L16-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.RealFourierOperator" href="#DFTK.RealFourierOperator"><code>DFTK.RealFourierOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Linear operators that act on tuples (real, fourier) The main entry point is <code>apply!(out, op, in)</code> which performs the operation out += op*in where out and in are named tuples (real, fourier) They also implement mul! and Matrix(op) for exploratory use.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/terms/operators.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.RealSpaceMultiplication" href="#DFTK.RealSpaceMultiplication"><code>DFTK.RealSpaceMultiplication</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Real space multiplication by a potential: (Hψ)(r) V(r) ψ(r)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/terms/operators.jl#L46-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.RestaMixing" href="#DFTK.RestaMixing"><code>DFTK.RestaMixing</code></a> — <span class="docstring-category">Type</span></header><section><div><p>We use a simplification of the Resta model DOI 10.1103/physrevb.16.2717 and set <span>$χ_0(q) = \frac{C_0 G^2}{4π (1 - C_0 G^2 / k_{TF}^2)} where$</span>C<em>0 = 1 - ε</em>r<span>$with$</span>ε<em>r<span>$being the macroscopic relative permittivity. We neglect$</span>f</em>\text{xc}<span>$, such that$</span>J^{-1} ≈ α \frac{k<em>{TF}^2 - C</em>0 G^2}{ε<em>r k</em>{TF}^2 - C_0 G^2}``</p><p>By default it assumes a relative permittivity of 10 (similar to Silicon). <code>εr == 1</code> is equal to <code>SimpleMixing</code> and <code>εr == Inf</code> to <code>KerkerMixing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.SimpleMixing" href="#DFTK.SimpleMixing"><code>DFTK.SimpleMixing</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Simple mixing: <span>$J^{-1} ≈ α$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.Xc" href="#DFTK.Xc"><code>DFTK.Xc</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Exchange-correlation term, defined by a list of functionals and usually evaluated through libxc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/terms/xc.jl#L4-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.CROP" href="#DFTK.CROP"><code>DFTK.CROP</code></a> — <span class="docstring-category">Function</span></header><section><div><p>CROP-accelerated root-finding iteration for <code>f</code>, starting from <code>x0</code> and keeping a history of <code>m</code> steps. Optionally <code>warming</code> specifies the number of non-accelerated steps to perform for warming up the history.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/scf/scf_solvers.jl#L100-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.DOS-Tuple{Any,Any,Any}" href="#DFTK.DOS-Tuple{Any,Any,Any}"><code>DFTK.DOS</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Total density of states at energy ε</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/postprocess/DOS.jl#L51-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.G_to_r!-Union{Tuple{Tf}, Tuple{Tr}, Tuple{AbstractArray{T,3} where T,PlaneWaveBasis,AbstractArray{T,3} where T}} where Tf where Tr" href="#DFTK.G_to_r!-Union{Tuple{Tf}, Tuple{Tr}, Tuple{AbstractArray{T,3} where T,PlaneWaveBasis,AbstractArray{T,3} where T}} where Tf where Tr"><code>DFTK.G_to_r!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>In-place version of <code>G_to_r</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/PlaneWaveBasis.jl#L281-L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.G_to_r-Tuple{PlaneWaveBasis,AbstractArray{T,3} where T}" href="#DFTK.G_to_r-Tuple{PlaneWaveBasis,AbstractArray{T,3} where T}"><code>DFTK.G_to_r</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">G_to_r(basis::PlaneWaveBasis, [kpt::Kpoint, ] f_fourier)</code></pre><p>Perform an iFFT to obtain the quantity defined by <code>f_fourier</code> defined on the k-dependent spherical basis set (if <code>kpt</code> is given) or the k-independent cubic (if it is not) on the real-space grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/PlaneWaveBasis.jl#L301-L307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.G_vectors-Tuple{Any}" href="#DFTK.G_vectors-Tuple{Any}"><code>DFTK.G_vectors</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the list of wave vectors (integer coordinates) for the cubic basis set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/PlaneWaveBasis.jl#L217-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.G_vectors-Tuple{Kpoint}" href="#DFTK.G_vectors-Tuple{Kpoint}"><code>DFTK.G_vectors</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The list of G vectors of a given <code>basis</code> or <code>kpoint</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/PlaneWaveBasis.jl#L26-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.LDOS-NTuple{4,Any}" href="#DFTK.LDOS-NTuple{4,Any}"><code>DFTK.LDOS</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Local density of states, in real space</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/postprocess/DOS.jl#L71-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.NOS-Tuple{Any,Any,Any}" href="#DFTK.NOS-Tuple{Any,Any,Any}"><code>DFTK.NOS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">NOS(ε, basis, eigenvalues; smearing=basis.model.smearing,
    temperature=basis.model.temperature)</code></pre><p>The number of Kohn-Sham states in a temperature window of width <code>temperature</code> around the energy <code>ε</code> contributing to the DOS at temperature <code>T</code>.</p><p>This quantity is not a physical quantity, but rather a dimensionless approximate measure for how well properties near the Fermi surface are sampled with the passed <code>smearing</code> and temperature <code>T</code>. It increases with both <code>T</code> and better sampling of the BZ with <span>$k$</span>-Points. A value <span>$\gg 1$</span> indicates a good sampling of properties near the Fermi surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/postprocess/DOS.jl#L12-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.ScfConvergenceDensity-Tuple{Any}" href="#DFTK.ScfConvergenceDensity-Tuple{Any}"><code>DFTK.ScfConvergenceDensity</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Flag convergence by using the L2Norm of the change between input density and unpreconditioned output density (ρout)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/scf/scf_callbacks.jl#L66-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.ScfConvergenceEnergy-Tuple{Any}" href="#DFTK.ScfConvergenceEnergy-Tuple{Any}"><code>DFTK.ScfConvergenceEnergy</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Flag convergence as soon as total energy change drops below tolerance</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/scf/scf_callbacks.jl#L47-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.ScfDefaultCallback-Tuple{}" href="#DFTK.ScfDefaultCallback-Tuple{}"><code>DFTK.ScfDefaultCallback</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Default callback function for <code>self_consistent_field</code>, which prints a convergence table</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/scf/scf_callbacks.jl#L23-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.ScfDiagtol-Tuple{}" href="#DFTK.ScfDiagtol-Tuple{}"><code>DFTK.ScfDiagtol</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Determine the tolerance used for the next diagonalization. This function takes <span>$|ρnext - ρin|$</span> and multiplies it with <code>ratio_ρdiff</code> to get the next <code>diagtol</code>, ensuring additionally that the returned value is between <code>diagtol_min</code> and <code>diagtol_max</code> and never increases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/scf/scf_callbacks.jl#L74-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.ScfPlotTrace" href="#DFTK.ScfPlotTrace"><code>DFTK.ScfPlotTrace</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Plot the trace of an SCF, i.e. the absolute error of the total energy at each iteration versus the converged energy in a semilog plot. By default a new plot canvas is generated, but an existing one can be passed and reused along with <code>kwargs</code> for the call to <code>plot!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/scf/scf_callbacks.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.anderson" href="#DFTK.anderson"><code>DFTK.anderson</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Anderson-accelerated root-finding iteration for finding a root of <code>f</code>, starting from <code>x0</code> and keeping a history of <code>m</code> steps. Optionally <code>warming</code> specifies the number of non-accelerated steps to perform for warming up the history.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/scf/scf_solvers.jl#L49-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.apply_kernel-Tuple{DFTK.Term,Any}" href="#DFTK.apply_kernel-Tuple{DFTK.Term,Any}"><code>DFTK.apply_kernel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">apply_kernel(term::Term, dρ; kwargs...)</code></pre><p>Computes the potential response to a perturbation dρ in real space</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/terms/terms.jl#L86-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.apply_ksymop-Tuple{Any,Any,Any,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T}" href="#DFTK.apply_ksymop-Tuple{Any,Any,Any,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T}"><code>DFTK.apply_ksymop</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Apply a symmetry operation to eigenvectors <code>ψk</code> at a given <code>kpoint</code> to obtain an equivalent point in [-0.5, 0.5)^3 and associated eigenvectors (expressed in the basis of the new kpoint).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/symmetry.jl#L123-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.apply_ksymop-Tuple{Any,RealFourierArray}" href="#DFTK.apply_ksymop-Tuple{Any,RealFourierArray}"><code>DFTK.apply_ksymop</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Apply a <code>k</code>-point symmetry operation (the tuple (S, τ)) to a partial density.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/symmetry.jl#L171-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.apply_χ0-Tuple{Any,Any,Any,Any,RealFourierArray}" href="#DFTK.apply_χ0-Tuple{Any,Any,Any,Any,RealFourierArray}"><code>DFTK.apply_χ0</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns the change in density <code>δρ</code> for a given <code>δV</code>. Drop all non-diagonal terms with (f(εn)-f(εm))/(εn-εm) factor less than <code>droptol</code>. If <code>sternheimer_contribution</code> is false, only compute excitations inside the provided orbitals.</p><p>Note: This function assumes that all bands contained in <code>ψ</code> and <code>eigenvalues</code> are sufficiently converged. By default the <code>self_consistent_field</code> routine of <code>DFTK</code> returns <code>3</code> extra bands, which are not converged by the eigensolver (see <code>n_ep_extra</code> parameter). These should be discarded before using this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/postprocess/chi0.jl#L119-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.atom_decay_length-Tuple{Any,Any}" href="#DFTK.atom_decay_length-Tuple{Any,Any}"><code>DFTK.atom_decay_length</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the lengthscale of the valence density for an atom with <code>n_elec_core</code> core and <code>n_elec_valence</code> valence electrons. ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/guess_density.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.build_fft_plans-Tuple{Type{Float32},Any}" href="#DFTK.build_fft_plans-Tuple{Type{Float32},Any}"><code>DFTK.build_fft_plans</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Plan a FFT of type <code>T</code> and size <code>fft_size</code>, spending some time on finding an optimal algorithm. Both an inplace and an out-of-place FFT plan are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/fft.jl#L40-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.build_form_factors-Tuple{Any,Any}" href="#DFTK.build_form_factors-Tuple{Any,Any}"><code>DFTK.build_form_factors</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Build form factors (Fourier transforms of projectors) for an atom centered at 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/terms/nonlocal.jl#L194-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.build_projection_vectors_-Union{Tuple{T}, Tuple{PlaneWaveBasis{T},Any,Kpoint}} where T" href="#DFTK.build_projection_vectors_-Union{Tuple{T}, Tuple{PlaneWaveBasis{T},Any,Kpoint}} where T"><code>DFTK.build_projection_vectors_</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Build projection vectors for a atoms array generated by term_nonlocal</p><p>H<em>at  = sum</em>ij Cij |pi&gt; &lt;pj| H<em>per = sum</em>R sum<em>ij Cij |pi(x-R)&gt; &lt;pj(x-R)|       = sum</em>R sum_ij Cij |pi(x-R)&gt; &lt;pj(x-R)|</p><p>&lt;e<em>kG&#39;|H</em>per|e<em>kG&gt; = ...                    = 1/Ω sum</em>ij Cij pihat(k+G&#39;) pjhat(k+G)^*</p><p>where pihat(q) = ∫_R^3 pi(r) e^{-iqr} dr</p><p>We store 1/√Ω pihat(k+G) in proj_vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/terms/nonlocal.jl#L148-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.bzmesh_ir_wedge-Tuple{Any,Any}" href="#DFTK.bzmesh_ir_wedge-Tuple{Any,Any}"><code>DFTK.bzmesh_ir_wedge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bzmesh_ir_wedge(kgrid_size, lattice, atoms; tol_symmetry=1e-5)</code></pre><p>Construct the irreducible wedge of a uniform Brillouin zone mesh for sampling <span>$k$</span>-Points. The function returns a tuple <code>(kcoords, ksymops)</code>, where <code>kcoords</code> are the list of irreducible <span>$k$</span>-Points and <code>ksymops</code> are a list of symmetry operations for regenerating the full mesh. <code>lattice</code> are the lattice vectors, column by column, <code>atoms</code> are pairs representing a mapping from <code>Element</code> objects to a list of positions in fractional coordinates. <code>tol_symmetry</code> is the tolerance used for searching for symmetry operations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/bzmesh.jl#L41-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.bzmesh_uniform-Tuple{Any}" href="#DFTK.bzmesh_uniform-Tuple{Any}"><code>DFTK.bzmesh_uniform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bzmesh_uniform(kgrid_size)</code></pre><p>Construct a uniform Brillouin zone mesh for sampling the <span>$k$</span>-Points. The function returns a tuple <code>(kcoords, ksymops)</code>, where <code>kcoords</code> are the list of <span>$k$</span>-Points and <code>ksymops</code> are a list of symmetry operations (for interface compatibility with <code>PlaneWaveBasis</code> and <code>bzmesh_irreducible</code>. No symmetry reduction is attempted, such that there will be <code>prod(kgrid_size)</code> <span>$k$</span>-Points returned and all symmetry operations are the identity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/bzmesh.jl#L25-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.charge_ionic-Tuple{DFTK.Element}" href="#DFTK.charge_ionic-Tuple{DFTK.Element}"><code>DFTK.charge_ionic</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the total ionic charge of an atom type (nuclear charge - core electrons)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/elements.jl#L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.charge_nuclear-Tuple{DFTK.Element}" href="#DFTK.charge_nuclear-Tuple{DFTK.Element}"><code>DFTK.charge_nuclear</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the total nuclear charge of an atom type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/elements.jl#L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.clear_without_conjugate!-Union{Tuple{AbstractArray{T,3}}, Tuple{T}} where T&lt;:Complex" href="#DFTK.clear_without_conjugate!-Union{Tuple{AbstractArray{T,3}}, Tuple{T}} where T&lt;:Complex"><code>DFTK.clear_without_conjugate!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Zero all elements of a Fourier space array which have no complex-conjugate partner and may thus lead to an imaginary component in real space (after an iFFT).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/common/check_real.jl#L17-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.compute_density-Tuple{PlaneWaveBasis,AbstractArray{T,1} where T,AbstractArray{T,1} where T}" href="#DFTK.compute_density-Tuple{PlaneWaveBasis,AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>DFTK.compute_density</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_density(basis::PlaneWaveBasis, ψ::AbstractVector, occupation::AbstractVector)</code></pre><p>Compute the density for a wave function <code>ψ</code> discretized on the plane-wave grid <code>basis</code>, where the individual k-Points are occupied according to <code>occupation</code>. <code>ψ</code> should be one coefficient matrix per k-Point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/densities.jl#L33-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.compute_kernel-Tuple{DFTK.Term}" href="#DFTK.compute_kernel-Tuple{DFTK.Term}"><code>DFTK.compute_kernel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_kernel(term::Term; kwargs...)</code></pre><p>Computes a matrix representation of the full response kernel (derivative of potential with respect to density) in real space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/terms/terms.jl#L77-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.compute_partial_density-NTuple{4,Any}" href="#DFTK.compute_partial_density-NTuple{4,Any}"><code>DFTK.compute_partial_density</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the partial density at the indicated <span>$k$</span>-Point and return it (in Fourier space).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/densities.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.compute_χ0-Tuple{Any}" href="#DFTK.compute_χ0-Tuple{Any}"><code>DFTK.compute_χ0</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the independent-particle susceptibility. Will blow up for large systems. Drop all non-diagonal terms with (f(εn)-f(εm))/(εn-εm) factor less than <code>droptol</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/postprocess/chi0.jl#L6-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.datadir_psp-Tuple{}" href="#DFTK.datadir_psp-Tuple{}"><code>DFTK.datadir_psp</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the data directory with pseudopotential files</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/pseudo/load_psp.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.determine_grid_size-Union{Tuple{T}, Tuple{AbstractArray{T,2},Any}} where T" href="#DFTK.determine_grid_size-Union{Tuple{T}, Tuple{AbstractArray{T,2},Any}} where T"><code>DFTK.determine_grid_size</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Determine the minimal grid size for the cubic basis set to be able to represent product of orbitals (with the default <code>supersampling=2</code>).</p><p>Optionally optimize the grid afterwards for the FFT procedure by ensuring factorization into small primes.</p><p>The function will determine the smallest cube containing the wave vectors  <span>$|G|^2/2 \leq E_\text{cut} ⋅ \text{supersampling}^2$</span>. For an exact representation of the density resulting from wave functions represented in the spherical basis sets, <code>supersampling</code> should be at least <code>2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/fft.jl#L3-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.diagonalize_all_kblocks-Tuple{Any,Hamiltonian,Int64}" href="#DFTK.diagonalize_all_kblocks-Tuple{Any,Hamiltonian,Int64}"><code>DFTK.diagonalize_all_kblocks</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function for diagonalising each <span>$k$</span>-Point blow of ham one step at a time. Some logic for interpolating between <span>$k$</span>-Points is used if <code>interpolate_kpoints</code> is true and if no guesses are given. <code>eigensolver</code> is the iterative eigensolver that really does the work, operating on a single <span>$k$</span>-Block. <code>eigensolver</code> should support the API <code>eigensolver(A, X0; prec, tol, maxiter)</code> <code>prec_type</code> should be a function that returns a preconditioner when called as <code>prec(ham, kpt)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/eigen/diag.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.direct_minimization-Tuple{PlaneWaveBasis}" href="#DFTK.direct_minimization-Tuple{PlaneWaveBasis}"><code>DFTK.direct_minimization</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Computes the ground state by direct minimization. <code>kwargs...</code> are passed to <code>Optim.Options()</code>. Note that the resulting ψ are not necessarily eigenvectors of the Hamiltonian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/scf/direct_minimization.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.divergence_real-Tuple{Any,Any}" href="#DFTK.divergence_real-Tuple{Any,Any}"><code>DFTK.divergence_real</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute divergence of an operand function, which returns the cartesian x,y,z components in real space when called with the arguments 1 to 3. The divergence is also returned as a real-space array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/terms/xc.jl#L209-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.energy_ewald-Tuple{Any,Any,Any}" href="#DFTK.energy_ewald-Tuple{Any,Any,Any}"><code>DFTK.energy_ewald</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the electrostatic interaction energy per unit cell between point charges in a uniform background of compensating charge to yield net neutrality. the <code>lattice</code> and <code>recip_lattice</code> should contain the lattice and reciprocal lattice vectors as columns. <code>charges</code> and <code>positions</code> are the point charges and their positions (as an array of arrays) in fractional coordinates. If <code>forces</code> is not nothing, minus the derivatives of the energy with respect to <code>positions</code> is computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/terms/ewald.jl#L53-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.energy_psp_correction-Tuple{Model}" href="#DFTK.energy_psp_correction-Tuple{Model}"><code>DFTK.energy_psp_correction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">energy_psp_correction(model)</code></pre><p>Compute the correction term for properly modelling the interaction of the pseudopotential core with the compensating background charge induced by the <code>Ewald</code> term.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/terms/psp_correction.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.eval_psp_energy_correction-Tuple{Any,PspHgh,Any}" href="#DFTK.eval_psp_energy_correction-Tuple{Any,PspHgh,Any}"><code>DFTK.eval_psp_energy_correction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eval_psp_energy_correction([T=Float64,] psp, n_electrons)</code></pre><p>Evaluate the energy correction to the Ewald electrostatic interaction energy of one unit cell, which is required compared the Ewald expression for point-like nuclei. <code>n_electrons</code> is the number of electrons per unit cell. This defines the uniform compensating background charge, which is assumed here.</p><p>Notice: The returned result is the <em>energy per unit cell</em> and not the energy per volume. To obtain the latter, the caller needs to divide by the unit cell volume.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/pseudo/PspHgh.jl#L283-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.eval_psp_local_fourier-Union{Tuple{T}, Tuple{PspHgh,T}} where T&lt;:Real" href="#DFTK.eval_psp_local_fourier-Union{Tuple{T}, Tuple{PspHgh,T}} where T&lt;:Real"><code>DFTK.eval_psp_local_fourier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eval_psp_local_fourier(psp, q)</code></pre><p>Evaluate the local part of the pseudopotential in reciprocal space.</p><p>This function computes V(q) = ∫<em>R^3 Vloc(r) e^{-iqr} dr      = 4π ∫</em>{R+} sin(qr)/q r e^{-iqr} dr</p><p><a href="6">GTH98</a> except they do it with plane waves normalized by 1/sqrt(Ω).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/pseudo/PspHgh.jl#L149-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.eval_psp_local_real-Union{Tuple{T}, Tuple{PspHgh,T}} where T&lt;:Real" href="#DFTK.eval_psp_local_real-Union{Tuple{T}, Tuple{PspHgh,T}} where T&lt;:Real"><code>DFTK.eval_psp_local_real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eval_psp_local_real(psp, r)</code></pre><p>Evaluate the local part of the pseudopotential in real space.</p><p><a href="1">GTH98</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/pseudo/PspHgh.jl#L185-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.eval_psp_projection_radial-Union{Tuple{T}, Tuple{PspHgh,Any,Any,T}} where T&lt;:Real" href="#DFTK.eval_psp_projection_radial-Union{Tuple{T}, Tuple{PspHgh,Any,Any,T}} where T&lt;:Real"><code>DFTK.eval_psp_projection_radial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eval_psp_projection_radial(psp::PspHgh, i, l, q::Number)</code></pre><p>Evaluate the radial part of the <code>i</code>-th projector for angular momentum <code>l</code> at the reciprocal vector with modulus <code>q</code>.</p><p>p(q) = ∫<em>{R+} r^2 p(r) j</em>l(q r) dr</p><p><a href="7-15">HGH98</a> except they do it with plane waves normalized by 1/sqrt(Ω).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/pseudo/PspHgh.jl#L250-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.eval_psp_projection_radial_real-Union{Tuple{T}, Tuple{PspHgh,Any,Any,T}} where T&lt;:Real" href="#DFTK.eval_psp_projection_radial_real-Union{Tuple{T}, Tuple{PspHgh,Any,Any,T}} where T&lt;:Real"><code>DFTK.eval_psp_projection_radial_real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eval_psp_projection_radial_real(psp::PspHgh, i, l, q::Real)</code></pre><p>Evaluate the radial part of the <code>i</code>-th projector for angular momentum <code>l</code> in real-space at the vector with modulus <code>r</code>. <a href="3">HGH98</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/pseudo/PspHgh.jl#L266-L272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.filled_occupation-Tuple{Any}" href="#DFTK.filled_occupation-Tuple{Any}"><code>DFTK.filled_occupation</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Maximal occupation of a state (2 for non-spin-polarized electrons, 1 otherwise).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/Model.jl#L182-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.find_fermi_level-Tuple{Any,Any}" href="#DFTK.find_fermi_level-Tuple{Any,Any}"><code>DFTK.find_fermi_level</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Find the Fermi level.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/occupation.jl#L5-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.find_irreducible_kpoints-Tuple{Any,Any,Any}" href="#DFTK.find_irreducible_kpoints-Tuple{Any,Any,Any}"><code>DFTK.find_irreducible_kpoints</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Implements a primitive search to find an irreducible subset of kpoints amongst the provided kpoints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/symmetry.jl#L75-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.find_occupation-Union{Tuple{T}, Tuple{PlaneWaveBasis{T},Any}} where T" href="#DFTK.find_occupation-Union{Tuple{T}, Tuple{PlaneWaveBasis{T},Any}} where T"><code>DFTK.find_occupation</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Find the occupation and Fermi level.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/occupation.jl#L12-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.find_occupation_bandgap-Tuple{Any,Any}" href="#DFTK.find_occupation_bandgap-Tuple{Any,Any}"><code>DFTK.find_occupation_bandgap</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Find Fermi level and occupation for the given parameters, assuming a band gap and zero temperature. This function is for DEBUG purposes only, and the finite-temperature version with 0 temperature should be preferred.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/occupation.jl#L86-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.guess_density-Tuple{PlaneWaveBasis}" href="#DFTK.guess_density-Tuple{PlaneWaveBasis}"><code>DFTK.guess_density</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">guess_density(basis)</code></pre><p>Build a superposition of atomic densities (SAD) guess density.</p><p>We take for the guess density a gaussian centered around the atom, of length specified by <code>atom_decay_length</code>, normalized to get the right number of electrons</p><div>\[\hat{ρ}(G) = Z \exp\left(-(2π \text{length} |G|)^2\right)\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/guess_density.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.hamiltonian_with_total_potential-Tuple{Hamiltonian,Any}" href="#DFTK.hamiltonian_with_total_potential-Tuple{Hamiltonian,Any}"><code>DFTK.hamiltonian_with_total_potential</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns a new Hamiltonian with local potential replaced by the given one</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/terms/Hamiltonian.jl#L130-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.index_G_vectors-Union{Tuple{T}, Tuple{PlaneWaveBasis,AbstractArray{T,1}}} where T&lt;:Integer" href="#DFTK.index_G_vectors-Union{Tuple{T}, Tuple{PlaneWaveBasis,AbstractArray{T,1}}} where T&lt;:Integer"><code>DFTK.index_G_vectors</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the index tuple <code>I</code> such that <code>G_vectors(basis)[I] == G</code> or the index <code>i</code> such that <code>G_vectors(kpoint)[i] == G</code>. Returns nothing if outside the range of valid wave vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/PlaneWaveBasis.jl#L236-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.interpolate_blochwave-Tuple{Any,Any,Any}" href="#DFTK.interpolate_blochwave-Tuple{Any,Any,Any}"><code>DFTK.interpolate_blochwave</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Interpolate Bloch wave between two basis sets. Limited feature set. Currently only interpolation to a bigger grid (larger Ecut) on the same lattice supported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/interpolation.jl#L88-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.interpolate_density-Tuple{RealFourierArray,PlaneWaveBasis}" href="#DFTK.interpolate_density-Tuple{RealFourierArray,PlaneWaveBasis}"><code>DFTK.interpolate_density</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Interpolate a function expressed in a basis <code>b_in</code> to a basis <code>b_out</code> This interpolation uses a very basic real-space algorithm, and makes a DWIM-y attempt to take into account the fact that b<em>out can be a supercell of b</em>in</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/interpolation.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.interpolate_kpoint-Tuple{Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,Kpoint,Kpoint}" href="#DFTK.interpolate_kpoint-Tuple{Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,Kpoint,Kpoint}"><code>DFTK.interpolate_kpoint</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Interpolate some data from one k-Point to another. The interpolation is fast, but not necessarily exact or even normalized. Intended only to construct guesses for iterative solvers</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/interpolation.jl#L65-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.is_metal" href="#DFTK.is_metal"><code>DFTK.is_metal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_metal(band_data, εF, tol)</code></pre><p>Determine whether the provided bands indicate the material is a metal, i.e. where bands are cut by the Fermi level.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/postprocess/band_structure.jl#L83-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.kgrid_monkhorst_pack-Tuple{Any}" href="#DFTK.kgrid_monkhorst_pack-Tuple{Any}"><code>DFTK.kgrid_monkhorst_pack</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct the coordinates of the kpoints in a (shifted) Monkorst-Pack grid</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/bzmesh.jl#L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.kgrid_size_from_minimal_spacing" href="#DFTK.kgrid_size_from_minimal_spacing"><code>DFTK.kgrid_size_from_minimal_spacing</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Selects a kgrid_size to ensure a minimal spacing (in inverse Bohrs) between kpoints. Default is <span>$2π * 0.04 \AA^{-1}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/bzmesh.jl#L145-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.lda_c_vwn!-Tuple{Any}" href="#DFTK.lda_c_vwn!-Tuple{Any}"><code>DFTK.lda_c_vwn!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>LDA correlation according to Vosko Wilk,and Nusair, (DOI 10.1139/p80-159)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/xc/lda_c_vwn.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.lda_x!-Tuple{Any}" href="#DFTK.lda_x!-Tuple{Any}"><code>DFTK.lda_x!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>LDA Slater exchange (DOI: 10.1017/S0305004100016108 and 10.1007/BF01340281)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/xc/lda_x.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.list_psp" href="#DFTK.list_psp"><code>DFTK.list_psp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">list_psp(element; functional, family, core, datadir_psp)</code></pre><p>List the pseudopotential files known to DFTK. Allows various ways to restrict the displayed files.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; list_psp(family=&quot;hgh&quot;)</code></pre><p>will list all HGH-type pseudopotentials and</p><pre><code class="language-julia-repl">julia&gt; list_psp(family=&quot;hgh&quot;, functional=&quot;lda&quot;)</code></pre><p>will only list those for LDA (also known as Pade in this context) and</p><pre><code class="language-julia-repl">julia&gt; list_psp(:O, core=:semicore)</code></pre><p>will list all oxygen semicore pseudopotentials known to DFTK.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/pseudo/list_psp.jl#L3-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.load_atoms-Tuple{Any,EtsfFolder}" href="#DFTK.load_atoms-Tuple{Any,EtsfFolder}"><code>DFTK.load_atoms</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Load a DFTK-compatible atoms object from the ETSF folder. Use the scalar type <code>T</code> to represent the data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/external/etsf_nanoquanta.jl#L51-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.load_atoms_pymatgen-Tuple{Any,PyCall.PyObject}" href="#DFTK.load_atoms_pymatgen-Tuple{Any,PyCall.PyObject}"><code>DFTK.load_atoms_pymatgen</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Load a DFTK-compatible atoms representation from a supported pymatgen object. All atoms are using a Coulomb model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/external/pymatgen.jl#L75-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.load_basis-Tuple{Any,EtsfFolder}" href="#DFTK.load_basis-Tuple{Any,EtsfFolder}"><code>DFTK.load_basis</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Load a DFTK-compatible basis object from the ETSF folder. Use the scalar type <code>T</code> to represent the data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/external/etsf_nanoquanta.jl#L117-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.load_density-Tuple{Any,EtsfFolder}" href="#DFTK.load_density-Tuple{Any,EtsfFolder}"><code>DFTK.load_density</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Load a DFTK-compatible density object from the ETSF folder. Use the scalar type <code>T</code> to represent the data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/external/etsf_nanoquanta.jl#L142-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.load_lattice-Tuple{Any,EtsfFolder}" href="#DFTK.load_lattice-Tuple{Any,EtsfFolder}"><code>DFTK.load_lattice</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Load a DFTK-compatible lattice object from the ETSF folder</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/external/etsf_nanoquanta.jl#L44-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.load_lattice-Tuple{Any,PyCall.PyObject}" href="#DFTK.load_lattice-Tuple{Any,PyCall.PyObject}"><code>DFTK.load_lattice</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Load a DFTK-compatible lattice object from a supported python object (e.g. pymatgen or ASE)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/external/load_from_python.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.load_model-Tuple{Any,EtsfFolder}" href="#DFTK.load_model-Tuple{Any,EtsfFolder}"><code>DFTK.load_model</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Load a DFTK-compatible model object from the ETSF folder. Use the scalar type <code>T</code> to represent the data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/external/etsf_nanoquanta.jl#L71-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.load_psp-Tuple{AbstractString}" href="#DFTK.load_psp-Tuple{AbstractString}"><code>DFTK.load_psp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">load_psp(key; datadir_psp)</code></pre><p>Load a pseudopotential file from the library of pseudopotentials. The file is searched in the directory <code>datadir_psp</code> and by the <code>key</code>. If the <code>key</code> is a path to a valid file, the extension is used to determine the type of the pseudopotential file format and a respective class is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/pseudo/load_psp.jl#L7-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.local_potential_fourier-Tuple{DFTK.Element,AbstractArray{T,1} where T}" href="#DFTK.local_potential_fourier-Tuple{DFTK.Element,AbstractArray{T,1} where T}"><code>DFTK.local_potential_fourier</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Radial local potential, in Fourier space: V(q) = int_{R^3} V(x) e^{-iqx} dx.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/elements.jl#L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.local_potential_real-Tuple{DFTK.Element,AbstractArray{T,1} where T}" href="#DFTK.local_potential_real-Tuple{DFTK.Element,AbstractArray{T,1} where T}"><code>DFTK.local_potential_real</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Radial local potential, in real space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/elements.jl#L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.model_DFT-Tuple{AbstractArray{T,2} where T,Array{T,1} where T,Any}" href="#DFTK.model_DFT-Tuple{AbstractArray{T,2} where T,Array{T,1} where T,Any}"><code>DFTK.model_DFT</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Build a DFT model from the specified atoms, with the specified functionals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/Model.jl#L158-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.model_LDA-Tuple{AbstractArray{T,2} where T,Array{T,1} where T}" href="#DFTK.model_LDA-Tuple{AbstractArray{T,2} where T,Array{T,1} where T}"><code>DFTK.model_LDA</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Build an LDA model (Teter93 parametrization) from the specified atoms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/Model.jl#L166-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.model_PBE-Tuple{AbstractArray{T,2} where T,Array{T,1} where T}" href="#DFTK.model_PBE-Tuple{AbstractArray{T,2} where T,Array{T,1} where T}"><code>DFTK.model_PBE</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Build an PBE-GGA model from the specified atoms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/Model.jl#L174-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.model_atomic-Tuple{AbstractArray{T,2} where T,Array{T,1} where T}" href="#DFTK.model_atomic-Tuple{AbstractArray{T,2} where T,Array{T,1} where T}"><code>DFTK.model_atomic</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Convenience constructor, which builds a standard atomic (kinetic + atomic potential) model. Use <code>extra_terms</code> to add additional terms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/Model.jl#L138-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.n_elec_core-Tuple{DFTK.Element}" href="#DFTK.n_elec_core-Tuple{DFTK.Element}"><code>DFTK.n_elec_core</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the number of core electrons</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/elements.jl#L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.n_elec_valence-Tuple{DFTK.Element}" href="#DFTK.n_elec_valence-Tuple{DFTK.Element}"><code>DFTK.n_elec_valence</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the number of valence electrons</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/elements.jl#L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.next_density-Tuple{Hamiltonian}" href="#DFTK.next_density-Tuple{Hamiltonian}"><code>DFTK.next_density</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Obtain new density ρ by diagonalizing <code>ham</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/scf/self_consistent_field.jl#L10-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.normalize_kpoint_coordinate-Tuple{Real}" href="#DFTK.normalize_kpoint_coordinate-Tuple{Real}"><code>DFTK.normalize_kpoint_coordinate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Bring kpoint coordinates into the range [-0.5, 0.5)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/bzmesh.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.parse_hgh_file-Tuple{Any}" href="#DFTK.parse_hgh_file-Tuple{Any}"><code>DFTK.parse_hgh_file</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parse_hgh_file(path; identifier=&quot;&quot;)</code></pre><p>Parse an HGH pseudopotential file and construct the PspHgh object. If <code>identifier</code> is given, this identifier will be set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/pseudo/PspHgh.jl#L45-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.plot_bandstructure-Tuple{Any,Any,Any}" href="#DFTK.plot_bandstructure-Tuple{Any,Any,Any}"><code>DFTK.plot_bandstructure</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute and plot the band structure. <code>n_bands</code> selects the number of bands to compute. If this value is absent and an <code>scfres</code> is used to start the calculation a default of <code>n_bands_scf + 5sqrt(n_bands_scf)</code> is used. Unlike the rest of DFTK bands energies are plotted in <code>:eV</code> unless a different <code>unit</code> is selected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/postprocess/band_structure.jl#L156-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.psp_local_polynomial" href="#DFTK.psp_local_polynomial"><code>DFTK.psp_local_polynomial</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The local potential of a HGH pseudopotentials in reciprocal space can be brought to the form <span>$Q(t) / (t^2 exp(t^2 / 2))$</span> where <span>$t = r_\text{loc} q$</span> and <code>Q</code> is a polynomial of at most degree 8. This function returns <code>Q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/pseudo/PspHgh.jl#L128-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.psp_projection_radial_polynomial" href="#DFTK.psp_projection_radial_polynomial"><code>DFTK.psp_projection_radial_polynomial</code></a> — <span class="docstring-category">Function</span></header><section><div><p>The nonlocal projectors of a HGH pseudopotentials in reciprocal space can be brought to the form <span>$Q(t) exp(-t^2 / 2)$</span> where <span>$t = r_l q$</span> and <code>Q</code> is a polynomial. This function returns <code>Q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/pseudo/PspHgh.jl#L203-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.qcut_psp_local-Tuple{Any,PspHgh}" href="#DFTK.qcut_psp_local-Tuple{Any,PspHgh}"><code>DFTK.qcut_psp_local</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Estimate an upper bound for the argument <code>q</code> after which <code>abs(eval_psp_local_fourier(psp, q))</code> is a strictly decreasing function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/pseudo/PspHgh.jl#L167-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.qcut_psp_projection_radial-Tuple{Any,PspHgh,Any,Any}" href="#DFTK.qcut_psp_projection_radial-Tuple{Any,PspHgh,Any,Any}"><code>DFTK.qcut_psp_projection_radial</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Estimate an upper bound for the argument <code>q</code> after which <code>eval_psp_projection_radial(psp, q)</code> is a strictly decreasing function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/pseudo/PspHgh.jl#L232-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.r_to_G!-Tuple{AbstractArray{T,3} where T,PlaneWaveBasis,AbstractArray{T,3} where T}" href="#DFTK.r_to_G!-Tuple{AbstractArray{T,3} where T,PlaneWaveBasis,AbstractArray{T,3} where T}"><code>DFTK.r_to_G!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>In-place version of <code>r_to_G!</code>. NOTE: If <code>kpt</code> is given, not only <code>f_fourier</code> but also <code>f_real</code> is overwritten.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/PlaneWaveBasis.jl#L318-L321">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.r_to_G-Tuple{PlaneWaveBasis,AbstractArray{T,3} where T}" href="#DFTK.r_to_G-Tuple{PlaneWaveBasis,AbstractArray{T,3} where T}"><code>DFTK.r_to_G</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">r_to_G(basis::PlaneWaveBasis, [kpt::Kpoint, ] f_real)</code></pre><p>Perform an FFT to obtain the Fourier representation of <code>f_real</code>. If <code>kpt</code> is given, the coefficients are truncated to the k-dependent spherical basis set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/PlaneWaveBasis.jl#L339-L345">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.r_vectors-Union{Tuple{PlaneWaveBasis{T}}, Tuple{T}} where T" href="#DFTK.r_vectors-Union{Tuple{PlaneWaveBasis{T}}, Tuple{T}} where T"><code>DFTK.r_vectors</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the list of r vectors, in reduced coordinates. By convention, this is in [0,1]^3.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/PlaneWaveBasis.jl#L228-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.run_abinit_scf-Tuple{Model,Any}" href="#DFTK.run_abinit_scf-Tuple{Model,Any}"><code>DFTK.run_abinit_scf</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Run an SCF in ABINIT starting from a DFTK <code>Model</code> and some extra parameters. Write the result to the <code>output</code> directory in ETSF Nanoquanta format and return the <code>EtsfFolder</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/external/abinit.jl#L60-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.run_abinit_scf-Tuple{PyCall.PyObject,Any}" href="#DFTK.run_abinit_scf-Tuple{PyCall.PyObject,Any}"><code>DFTK.run_abinit_scf</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Run an SCF in ABINIT starting from the input file <code>infile</code> represented as a <code>abipy.abilab.AbinitInput</code> python object. Write the result to the <code>output</code> directory in ETSF Nanoquanta format and return the result as an <code>EtsfFolder</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/external/abinit.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.scf_damping_solver" href="#DFTK.scf_damping_solver"><code>DFTK.scf_damping_solver</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Create a damped SCF solver updating the density as <code>x = β * x_new + (1 - β) * x</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/scf/scf_solvers.jl#L25-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.scf_nlsolve_solver" href="#DFTK.scf_nlsolve_solver"><code>DFTK.scf_nlsolve_solver</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Create a NLSolve-based SCF solver, by default using an Anderson-accelerated fixed-point scheme, keeping <code>m</code> steps for Anderson acceleration. See the NLSolve documentation for details about the other parameters and methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/scf/scf_solvers.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.select_eigenpairs_all_kblocks-Tuple{Any,Any}" href="#DFTK.select_eigenpairs_all_kblocks-Tuple{Any,Any}"><code>DFTK.select_eigenpairs_all_kblocks</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function to select a subset of eigenpairs on each <span>$k$</span>-Point. Works on the Tuple returned by <code>diagonalize_all_kblocks</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/eigen/diag.jl#L65-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.self_consistent_field-Tuple{PlaneWaveBasis}" href="#DFTK.self_consistent_field-Tuple{PlaneWaveBasis}"><code>DFTK.self_consistent_field</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Solve the Kohn-Sham equations with a SCF algorithm, starting at ρ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/scf/self_consistent_field.jl#L38-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.spglib_atommapping-Tuple{Any}" href="#DFTK.spglib_atommapping-Tuple{Any}"><code>DFTK.spglib_atommapping</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct a tuple containing the positions of the species in the convention required to take the place of a <code>cell</code> datastructure used in spglib.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/external/spglib.jl#L14-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.standardize_atoms" href="#DFTK.standardize_atoms"><code>DFTK.standardize_atoms</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Apply various standardisations to a lattice and a list of atoms. It uses spglib to detect symmetries (within <code>tol_symmetry</code>), then cleans up the lattice according to the symmetries (unless <code>correct_symmetry</code> is <code>false</code>) and returns the resulting standard lattice and atoms. If <code>primitive</code> is <code>true</code> (default) the primitive unit cell is returned, else the conventional unit cell is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/bzmesh.jl#L136-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.symmetrize-Tuple{RealFourierArray}" href="#DFTK.symmetrize-Tuple{RealFourierArray}"><code>DFTK.symmetrize</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Symmetrize a <code>RealFourierArray</code> by applying all the model symmetries (by default) and forming the average.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/symmetry.jl#L222-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.symmetry_operations-Tuple{Any,Any}" href="#DFTK.symmetry_operations-Tuple{Any,Any}"><code>DFTK.symmetry_operations</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the <span>$k$</span>-point symmetry operations associated to a lattice, model or basis. Since the <span>$k$</span>-point discretisations may break some of the symmetries, the latter case will return a subset of the symmetries of the former two.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/symmetry.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.total_local_potential-Tuple{Hamiltonian}" href="#DFTK.total_local_potential-Tuple{Hamiltonian}"><code>DFTK.total_local_potential</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the total local potential of the given Hamiltonian, in real space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/terms/Hamiltonian.jl#L119-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.unit_to_au-Tuple{Symbol}" href="#DFTK.unit_to_au-Tuple{Symbol}"><code>DFTK.unit_to_au</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unit_to_ao(symbol)</code></pre><p>Get the factor converting from the unit <code>symbol</code> to atomic units. E.g. <code>unit_to_au(:eV)</code> returns the conversion factor from electron volts to Hartree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/common/units.jl#L14-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.ylm_real-Union{Tuple{T}, Tuple{Integer,Integer,AbstractArray{T,1}}} where T" href="#DFTK.ylm_real-Union{Tuple{T}, Tuple{Integer,Integer,AbstractArray{T,1}}} where T"><code>DFTK.ylm_real</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns the (l,m) real spherical harmonic Y<em>lm(r). Consistent with https://en.wikipedia.org/wiki/Table</em>of<em>spherical</em>harmonics#Real<em>spherical</em>harmonics</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/common/spherical_harmonics.jl#L4-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.@timing-Tuple" href="#DFTK.@timing-Tuple"><code>DFTK.@timing</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Shortened version of the <code>@timeit</code> macro from <code>TimerOutputs</code>, which writes to the DFTK timer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/common/timer.jl#L11-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.@timing_seq-Tuple" href="#DFTK.@timing_seq-Tuple"><code>DFTK.@timing_seq</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Similar to <code>@timing</code>, but disabled in parallel runs. Should be used to time threaded regions, since TimerOutputs is not thread-safe and breaks otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/common/timer.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.Smearing.entropy-Tuple{DFTK.Smearing.SmearingFunction,Any}" href="#DFTK.Smearing.entropy-Tuple{DFTK.Smearing.SmearingFunction,Any}"><code>DFTK.Smearing.entropy</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Entropy. Note that this is a function of the energy <code>x</code>, not of <code>occupation(x)</code>. This function satisfies s&#39; = x f&#39; (see https://www.vasp.at/vasp-workshop/k-points.pdf p. 12 and https://arxiv.org/pdf/1805.07144.pdf p. 18.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/Smearing.jl#L50-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.Smearing.occupation-Tuple{DFTK.Smearing.SmearingFunction,Any}" href="#DFTK.Smearing.occupation-Tuple{DFTK.Smearing.SmearingFunction,Any}"><code>DFTK.Smearing.occupation</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Occupation at <code>x</code>, where in practice x = (ε - εF) / T.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/Smearing.jl#L16-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.Smearing.occupation_derivative-Tuple{DFTK.Smearing.SmearingFunction,Any}" href="#DFTK.Smearing.occupation_derivative-Tuple{DFTK.Smearing.SmearingFunction,Any}"><code>DFTK.Smearing.occupation_derivative</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Derivative of the occupation function, approximation to minus the delta function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/Smearing.jl#L21-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DFTK.Smearing.occupation_divided_difference-Tuple{DFTK.Smearing.SmearingFunction,Any,Any,Any,Any}" href="#DFTK.Smearing.occupation_divided_difference-Tuple{DFTK.Smearing.SmearingFunction,Any,Any,Any,Any}"><code>DFTK.Smearing.occupation_divided_difference</code></a> — <span class="docstring-category">Method</span></header><section><div><p>(f(x) - f(y))/(x - y), computed stably in the case where x and y are close</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/c317c277e469b2d6c5b01646b700ce2a170015ac/src/Smearing.jl#L26-L28">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../advanced/symmetries/">« Crystal symmetries</a><a class="docs-footer-nextpage" href="../publications/">Publications »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 25 July 2020 16:56">Saturday 25 July 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
