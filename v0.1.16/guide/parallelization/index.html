<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Timings and parallelization · DFTK.jl</title><link rel="canonical" href="https://juliamolsim.github.io/DFTK.jl/stable/guide/parallelization/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DFTK.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">DFTK.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Getting started</span><ul><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li class="is-active"><a class="tocitem" href>Timings and parallelization</a><ul class="internal"><li><a class="tocitem" href="#Timing-measurements"><span>Timing measurements</span></a></li><li><a class="tocitem" href="#Threading"><span>Threading</span></a></li><li><a class="tocitem" href="#MPI"><span>MPI</span></a></li></ul></li><li><a class="tocitem" href="../density_functional_theory/">Density-functional theory</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/metallic_systems/">Temperature and metallic systems</a></li><li><a class="tocitem" href="../../examples/pymatgen/">Creating supercells with pymatgen</a></li><li><a class="tocitem" href="../../examples/ase/">Creating slabs with ASE</a></li><li><a class="tocitem" href="../../examples/collinear_magnetism/">Collinear spin and magnetic systems</a></li><li><a class="tocitem" href="../../examples/geometry_optimization/">Geometry optimization</a></li><li><a class="tocitem" href="../../examples/scf_callbacks/">Monitoring self-consistent field calculations</a></li><li><a class="tocitem" href="../../examples/scf_checkpoints/">Saving SCF results on disk and SCF checkpoints</a></li><li><a class="tocitem" href="../../examples/polarizability/">Polarizability by linear response</a></li><li><a class="tocitem" href="../../examples/gross_pitaevskii/">Gross-Pitaevskii equation in one dimension</a></li><li><a class="tocitem" href="../../examples/gross_pitaevskii_2D/">Gross-Pitaevskii equation with magnetism</a></li><li><a class="tocitem" href="../../examples/cohen_bergstresser/">Cohen-Bergstresser model</a></li><li><a class="tocitem" href="../../examples/arbitrary_floattype/">Arbitrary floating-point types</a></li><li><a class="tocitem" href="../../examples/custom_solvers/">Custom solvers</a></li><li><a class="tocitem" href="../../examples/custom_potential/">Custom potential</a></li></ul></li><li><span class="tocitem">Advanced topics</span><ul><li><a class="tocitem" href="../../advanced/conventions/">Notation and conventions</a></li><li><a class="tocitem" href="../../advanced/data_structures/">Data structures</a></li><li><a class="tocitem" href="../../advanced/useful_formulas/">Useful formulas</a></li><li><a class="tocitem" href="../../advanced/symmetries/">Crystal symmetries</a></li></ul></li><li><a class="tocitem" href="../../api/">API reference</a></li><li><a class="tocitem" href="../../publications/">Publications</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Getting started</a></li><li class="is-active"><a href>Timings and parallelization</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Timings and parallelization</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaMolSim/DFTK.jl/blob/master/docs/src/guide/parallelization.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Timings-and-parallelization"><a class="docs-heading-anchor" href="#Timings-and-parallelization">Timings and parallelization</a><a id="Timings-and-parallelization-1"></a><a class="docs-heading-anchor-permalink" href="#Timings-and-parallelization" title="Permalink"></a></h1><p>This section summarizes the options DFTK offers to monitor and influence performance of the code.</p><h2 id="Timing-measurements"><a class="docs-heading-anchor" href="#Timing-measurements">Timing measurements</a><a id="Timing-measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Timing-measurements" title="Permalink"></a></h2><p>By default DFTK uses <a href="https://github.com/KristofferC/TimerOutputs.jl">TimerOutputs.jl</a> to record timings, memory allocations and the number of calls for selected routines inside the code. These numbers are accessible in the object <code>DFTK.timer</code>. Since the timings are automatically accumulated inside this datastructure, any timing measurement should first reset this timer before running the calculation of interest.</p><p>For example to measure the timing of an SCF:</p><pre><code class="language-julia">DFTK.reset_timer!(DFTK.timer)
scfres = self_consistent_field(basis, tol=1e-8)

DFTK.timer</code></pre><pre class="documenter-example-output"> ──────────────────────────────────────────────────────────────────────────────
                                       Time                   Allocations      
                               ──────────────────────   ───────────────────────
       Tot / % measured:            769ms / 23.4%            116MiB / 33.2%    

 Section               ncalls     time   %tot     avg     alloc   %tot      avg
 ──────────────────────────────────────────────────────────────────────────────
 self_consistent_field      1    179ms  99.5%   179ms   38.3MiB  99.4%  38.3MiB
   LOBPCG                  14    108ms  60.3%  7.74ms   11.8MiB  30.7%   866KiB
     Hamiltonian mu...     43   74.4ms  41.4%  1.73ms   2.96MiB  7.68%  70.4KiB
       kinetic+local       43   69.8ms  38.8%  1.62ms    196KiB  0.50%  4.56KiB
       nonlocal            43   2.06ms  1.14%  47.8μs    834KiB  2.11%  19.4KiB
     rayleigh_ritz         29   6.12ms  3.41%   211μs    941KiB  2.39%  32.5KiB
     ortho                107   4.90ms  2.72%  45.8μs    905KiB  2.30%  8.46KiB
     block multipli...    117   3.48ms  1.93%  29.7μs   1.65MiB  4.28%  14.4KiB
   compute_density          7   32.0ms  17.8%  4.57ms   5.44MiB  14.1%   796KiB
   energy_hamiltonian      15   29.6ms  16.5%  1.98ms   13.3MiB  34.4%   905KiB
     ene_ops               15   24.4ms  13.6%  1.63ms   9.13MiB  23.7%   624KiB
       ene_ops: xc         15   13.2ms  7.33%   879μs   2.85MiB  7.41%   195KiB
       ene_ops: har...     15   4.73ms  2.63%   315μs   3.97MiB  10.3%   271KiB
       ene_ops: local      15   2.42ms  1.35%   161μs   1.61MiB  4.18%   110KiB
       ene_ops: non...     15   1.89ms  1.05%   126μs    159KiB  0.40%  10.6KiB
       ene_ops: kin...     15   1.26ms  0.70%  84.0μs    528KiB  1.34%  35.2KiB
   QR orthonormaliz...     14    400μs  0.22%  28.5μs    159KiB  0.40%  11.4KiB
   SimpleMixing             7    232μs  0.13%  33.1μs    959KiB  2.43%   137KiB
 guess_density              1    926μs  0.52%   926μs    231KiB  0.59%   231KiB
 guess_spin_density         1    304ns  0.00%   304ns     0.00B  0.00%    0.00B
 ──────────────────────────────────────────────────────────────────────────────</pre><p>The output produced when printing or displaying the <code>DFTK.timer</code> now shows a nice table summarising total time and allocations as well as a breakdown over individual routines.</p><div class="admonition is-info"><header class="admonition-header">Timing measurements and stack traces</header><div class="admonition-body"><p>Timing measurements have the unfortunate disadvantage that they alter the way stack traces look making it sometimes harder to find errors when debugging. For this reason timing measurements can be disabled completely (i.e. not even compiled into the code) by setting the environment variable <code>DFTK_TIMING</code> to <code>&quot;0&quot;</code> or <code>&quot;false&quot;</code>. For this to take effect recompiling all DFTK (including the precompile cache) is needed.</p></div></div><div class="admonition is-info"><header class="admonition-header">Timing measurements and threading</header><div class="admonition-body"><p>Unfortunately measuring timings in <code>TimerOutputs</code> is not yet thread-safe. Therefore taking timings of threaded parts of the code will be disabled unless you set <code>DFTK_TIMING</code> to <code>&quot;all&quot;</code>. In this case you must not use Julia threading (see section below) or otherwise undefined behaviour results.</p></div></div><h2 id="Threading"><a class="docs-heading-anchor" href="#Threading">Threading</a><a id="Threading-1"></a><a class="docs-heading-anchor-permalink" href="#Threading" title="Permalink"></a></h2><p>At the moment DFTK employs shared-memory parallelism using multiple levels of threading which distribute the workload over different <span>$k$</span>-Points, bands or within an FFT or BLAS call between processors. At its current stage our approach to threading is quite simple and pragmatic, such that we do not yet achieve a great scaling. This should be improved in future versions of the code.</p><p>Finding a good sweet spot between the number of threads to use and the extra performance gained by each additional working core is not always easy, since starting, terminating and synchronising threads takes time as well. Most importantly the best settings wrt. threading depend on both hardware and the problem (e.g. number of bands, <span>$k$</span>-Points, FFT grid size).</p><p>For the moment DFTK does not offer an automated selection mechanism of thread and parallelization threading and just uses the Julia defaults. Since these are rarely good, users are advised to use the timing capabilities of DFTK to experiment with threading for their particular use case before running larger calculations.</p><h3 id="FFTW-threads"><a class="docs-heading-anchor" href="#FFTW-threads">FFTW threads</a><a id="FFTW-threads-1"></a><a class="docs-heading-anchor-permalink" href="#FFTW-threads" title="Permalink"></a></h3><p>For typical small to medium-size calculations in DFTK the largest part of time is spent doing discrete Fourier transforms (about 80 to 90%). For this reason parallelising FFTs can have a large effect on the runtime of larger calculation in DFTK. Unfortunately for scaling of FFT threading for smaller problem sizes and large numbers of threads is not great, such that by default threading in FFTW is even disabled.</p><p>The <strong>recommended setting</strong> for FFT threading with DFTK is therefore to only use moderate number of FFT threads, something like <span>$2$</span> or <span>$4$</span> and for smaller calculations disable FFT threading completely. To <strong>enable parallelization of FFTs</strong> (which is by default disabled), use</p><pre><code class="language-none">using FFTW
FFTW.set_num_threads(N)</code></pre><p>where <code>N</code> is the number of threads you desire.</p><h3 id="BLAS-threads"><a class="docs-heading-anchor" href="#BLAS-threads">BLAS threads</a><a id="BLAS-threads-1"></a><a class="docs-heading-anchor-permalink" href="#BLAS-threads" title="Permalink"></a></h3><p>All BLAS calls in Julia go through a parallelized OpenBlas or MKL (with <a href="https://github.com/JuliaComputing/MKL.jl">MKL.jl</a>. Generally threading in BLAS calls is far from optimal and the default settings can be pretty bad. For example for CPUs with hyper threading enabled, the default number of threads seems to equal the number of <em>virtual</em> cores. Still, BLAS calls typically take second place in terms of the share of runtime they make up (between 10% and 20%). Of note many of these do not take place on matrices of the size of the full FFT grid, but rather only in a subspace (e.g. orthogonalization, Rayleigh-Ritz, ...) such that parallelization is either anyway disabled by the BLAS library or not very effective.</p><p>The <strong>recommendation</strong> is therefore to use the same number of threads as for the FFT threads. You can set the number of BLAS threads by</p><pre><code class="language-none">using LinearAlgebra
BLAS.set_num_threads(N)</code></pre><p>where <code>N</code> is the number of threads you desire. To <strong>check the number of BLAS threads</strong> currently used, you can use</p><pre><code class="language-none">Int(ccall((BLAS.@blasfunc(openblas_get_num_threads), BLAS.libblas), Cint, ()))</code></pre><p>or (from Julia 1.6) simply <code>BLAS.get_num_threads()</code>.</p><h3 id="Julia-threads"><a class="docs-heading-anchor" href="#Julia-threads">Julia threads</a><a id="Julia-threads-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-threads" title="Permalink"></a></h3><p>On top of FFT and BLAS threading DFTK uses Julia threads (<code>Thread.@threads</code>) in a couple of places to parallelize over <code>k</code>-Points (density computation) or bands (Hamiltonian application). The number of threads used for these aspects is controlled by the <em>environment variable</em> <code>JULIA_NUM_THREADS</code>. To influence the number of Julia threads used, set this variable <em>before</em> starting the Julia process.</p><p>Notice, that Julia threading is applied on top of FFTW and BLAS threading in the sense that the regions parallelized by Julia threads again use parallelized FFT and BLAS calls, such that the effects are not orthogonal. Compared to FFT and BLAS threading the parallelization implied by using Julia threads tends to scale better, but its effectiveness is limited by the number of bands and the number of irreducible <code>k</code>-Points used in the calculation. Therefore this good scaling quickly diminishes for small to medium systems.</p><p>The <strong>recommended setting</strong> is to stick to <code>2</code> Julia threads and to use <code>4</code> or more Julia threads only for large systems and/or many <code>k</code>-Points. To <strong>check the number of Julia threads</strong> use <code>Threads.nthreads()</code>.</p><h3 id="Summary-of-recommended-settings"><a class="docs-heading-anchor" href="#Summary-of-recommended-settings">Summary of recommended settings</a><a id="Summary-of-recommended-settings-1"></a><a class="docs-heading-anchor-permalink" href="#Summary-of-recommended-settings" title="Permalink"></a></h3><table><tr><th style="text-align: right">Calculation size</th><th style="text-align: right"><code>JULIA_NUM_THREADS</code></th><th style="text-align: right"><code>FFTW.set_num_threads(N)</code></th><th style="text-align: right"><code>BLAS.set_num_threads(N)</code></th></tr><tr><td style="text-align: right">tiny</td><td style="text-align: right">1</td><td style="text-align: right">1</td><td style="text-align: right">1</td></tr><tr><td style="text-align: right">small</td><td style="text-align: right">2</td><td style="text-align: right">1</td><td style="text-align: right">1</td></tr><tr><td style="text-align: right">medium</td><td style="text-align: right">2</td><td style="text-align: right">2</td><td style="text-align: right">2</td></tr><tr><td style="text-align: right">large</td><td style="text-align: right">2</td><td style="text-align: right">4</td><td style="text-align: right">4</td></tr></table><p>Note, that this picture is likely to change in future versions of DFTK and Julia as improvements to threading and parallelization are made in the language or the code.</p><h2 id="MPI"><a class="docs-heading-anchor" href="#MPI">MPI</a><a id="MPI-1"></a><a class="docs-heading-anchor-permalink" href="#MPI" title="Permalink"></a></h2><p>DFTK uses MPI to distribute on kpoints only at the moment. This should be the most performant method of parallelization: if you have kpoints, start by disabling all threading and use this. Simply follow the instructions on <a href="https://github.com/JuliaParallel/MPI.jl">MPI.jl</a> and run DFTK under MPI:</p><pre><code class="language-none">mpiexecjl -np 16 julia myscript.jl</code></pre><p>Notice that we use mpiexecjl (see MPI.jl docs) to automatically select the <code>mpiexec</code> compatible with the MPI version used by Julia.</p><p>Issues and workarounds:</p><ul><li>Printing is garbled, as usual with MPI. You can use<pre><code class="language-julia">DFTK.mpi_master() || (redirect_stdout(); redirect_stderr())</code></pre>at the top of your script to disable printing on all processes but one.</li><li>This feature is still experimental and some routines (e.g. band structure and direct minimization) are not compatible with this yet.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« Tutorial</a><a class="docs-footer-nextpage" href="../density_functional_theory/">Density-functional theory »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 5 November 2020 12:08">Thursday 5 November 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
