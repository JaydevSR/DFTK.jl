<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DFTK.jl: The density-functional toolkit. · DFTK</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DFTK</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>DFTK.jl: The density-functional toolkit.</a><ul class="internal"><li><a class="toctext" href="#Terminology-and-Definitions-1">Terminology and Definitions</a></li><li><a class="toctext" href="#Lattices-1">Lattices</a></li><li><a class="toctext" href="#Units-1">Units</a></li><li><a class="toctext" href="#Plane-wave-basis-functions-1">Plane wave basis functions</a></li><li><a class="toctext" href="#Basis-sets-1">Basis sets</a></li><li><a class="toctext" href="#Real-space-grids-1">Real-space grids</a></li><li><a class="toctext" href="#Core-1">Core</a></li><li><a class="toctext" href="#Utilities-1">Utilities</a></li><li><a class="toctext" href="#Definition-of-builder-functions-1">Definition of builder functions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>DFTK.jl: The density-functional toolkit.</a></li></ul><a class="edit-page" href="https://github.com/JuliaMolSim/DFTK.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>DFTK.jl: The density-functional toolkit.</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="DFTK.jl:-The-density-functional-toolkit.-1" href="#DFTK.jl:-The-density-functional-toolkit.-1">DFTK.jl: The density-functional toolkit.</a></h1><p>DFTK is a <code>julia</code> package of for playing with plane-wave density-functional theory algorithms.</p><h2><a class="nav-anchor" id="Terminology-and-Definitions-1" href="#Terminology-and-Definitions-1">Terminology and Definitions</a></h2><p>The general terminology used throughout the documentation of the plane-wave aspects of the code.</p><h2><a class="nav-anchor" id="Lattices-1" href="#Lattices-1">Lattices</a></h2><p>Usually we denote with <span>$A$</span> the matrix containing all lattice vectors as columns and with</p><div>\[\textbf{B} = 2\pi \textbf{A}^{-T}\]</div><p>the matrix containing the reciprocal lattice vectors as columns.</p><h2><a class="nav-anchor" id="Units-1" href="#Units-1">Units</a></h2><p>Unless otherwise stated the code and documentation uses atomic units and fractional or integer coordinates for <span>$k$</span>-Points and wave vectors <span>$G$</span>. The equivalent Vectors in cartesian coordiates will be denoted as <span>$k^c$</span> or <span>$G^c$</span>, i.e.</p><div>\[k^c = \textbf{B} k \quad G^c = \textbf{B} G.\]</div><h2><a class="nav-anchor" id="Plane-wave-basis-functions-1" href="#Plane-wave-basis-functions-1">Plane wave basis functions</a></h2><p>At the moment the code works exclusively with orthonormal plane waves. In other words our bases consist of functions</p><div>\[e_{G^c} = 1/\sqrt{\Omega} e^{i\, G^c \cdot x}\]</div><p>where <span>$\Omega$</span> is the unit cell volume and <span>$G^c$</span> is a wave vector in cartesian coordiates.</p><h2><a class="nav-anchor" id="Basis-sets-1" href="#Basis-sets-1">Basis sets</a></h2><ul><li><p>The <strong>wave-function basis</strong> <span>$B_k$</span>, consisting of all plane-wave basis functions below the desired energy cutoff <span>$E_\text{cut}$</span> for each <span>$k$</span>-point:</p><div>\[B_k = \{ e_{G^c} : 1/2 |G^c + k^c|^2 ≤ E_\text{cut}.\]</div><p>Geometrically the corresponding wave vectors <span>$G^c$</span> form a ball of radius <span>$\sqrt{2 E_\text{cut}}$</span> centred at <span>$k^c$</span>. This makes the corresponding set of <span>$G$</span>-vectors</p><div>\[\{ G : |\textbf{B} (G + k)| ≤ 2 \sqrt{E_\text{cut}} \}\]</div><p>in integer coordinates an ellipsoid.</p></li><li><p>The <strong>potential</strong> or <strong>density basis</strong> <span>$B_\rho$</span>, consisting of all plane waves on which a potential needs to be known in order to be consistent with the union of all <span>$B_k$</span> for all <span>$k$</span>. This means that it is the set</p><div>\[B_\rho = \{ e_{G^c} - e_{\tilde{G}^c} : e_{G^c}, e_{\tilde{G}^c} \in B_k \}.\]</div><p>This is equivalent to the alternative definition</p><div>\[B_\rho = \{ e_{G^c} : 1/2 |G^c|^2 ≤ α^2 E_\text{cut} \},\]</div><p>for a supersampling factor <span>$\alpha = 2$</span>. Geometrically this is again a ball in cartesian coordinates and an ellipsoid in integer coordinates.</p></li><li><p>In practice we do not use <span>$B_\rho$</span> in the code, since fast-fourier transforms (FFT) operate on rectangular grids instead. For this reason the code determines <span>$C_\rho$</span>, the smallest rectangular grid in integer coordinates which contains all <span>$G$</span>-vectors corresponding to the plane waves of <span>$B_\rho$</span>. For this we take</p><div>\[C_\rho = \{ G = (G_1, G_2, G_3)^T : |G_i| ≤ N_i \}\]</div><p>where the bounds <span>$N_i$</span> are determined as follows. Since <span>$G = \textbf{B}^{-1} G^c$</span> one can employ Cauchy-Schwartz to get</p><div>\[N_i = max_{|G^c|^2 ≤ 2 α^2 E_\text{cut}}(\textbf{B}^{-1}[i, :] \cdot G^c)
    ≤ |\textbf{B}^{-1}[i, :]| \sqrt{2 α^2 E_\text{cut}}.\]</div><p>With <span>$\textbf{B}^{-1} = frac{1}{2\pi} \textbf{A}^T$</span> therefore</p><div>\[N_i ≤ |\textbf{A}[:, i]| \frac{\sqrt{2 α^2 E_\text{cut}}}{2π}\]</div><p>where e.g. <span>$\textbf{A}[:, i]$</span> denotes the <span>$i$</span>-th column of <span>$\textbf{A}$</span>. Notice, that this makes <span>$C_\rho$</span> is a rectangular shape in integer coordinates, but a parallelepiped in cartesian coordinates.</p></li></ul><h6><a class="nav-anchor" id="TODO-not-yet-properly-updated-from-here-1" href="#TODO-not-yet-properly-updated-from-here-1">TODO not yet properly updated from here</a></h6><ul><li>The <strong>XC basis</strong> <span>$B_\text{XC}$</span>, which is used for computing the application of the exchange-correlation potential operator to the density <span>$\rho$</span>, represented in the basis <span>$B_\rho$</span>, that is<div>\[B_\text{XC}  = \{e_G : 1/2 |G|_\text{max}^2 ≤ β E_\text{cut} \}.\]</div>Since the exchange-correlation potential might involve arbitrary powers of the density <span>$ρ$</span>, a numerically exact computation of the integral<div>\[\langle e_G | V_\text{XC}(ρ) e_{G&#39;} \rangle \qquad \text{with} \qquad e_G, e_{G&#39;} ∈ B_{Ψ,k}\]</div>requires the exchange-correlation supersampling factor <span>$\beta$</span> to be infinite. In practice, <span>$\beta =4$</span> is usually chosen, such that <span>$B_\text{XC} = B_\rho$</span>.</li></ul><h2><a class="nav-anchor" id="Real-space-grids-1" href="#Real-space-grids-1">Real-space grids</a></h2><p>Due to the Fourier-duality of reciprocal-space and real-space lattice, the above basis sets define corresponding real-space grids as well:</p><ul><li>The grid <span>$B_\rho^\ast$</span>, the <strong>potential integration grid</strong>, which is the grid used for convolutions of a potential with the discretized representation of a DFT orbital. It is simply the iFFT-dual real-space grid of <span>$B_\rho$</span>.</li><li>The grid <span>$B^\ast_\text{XC}$</span>, the <strong>exchange-correlation integration grid</strong>, i.e. the grid used for convolutions of the exchange-correlation functional terms with the density or derivatives of it. It is the iFFT-dual of <span>$B_\text{XC}$</span>.</li></ul><h2><a class="nav-anchor" id="Core-1" href="#Core-1">Core</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.PlaneWaveBasis" href="#DFTK.PlaneWaveBasis"><code>DFTK.PlaneWaveBasis</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>TODO docme</p><p>fft_size is now Fourier grid size kcoords is vector of Vec3</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/ca41d97753148d8d973f5a8b6617d76c558ba742/src/core/PlaneWaveBasis.jl#L122-L127">source</a></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>set_kpoints!</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>basis_ρ</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.G_to_r!" href="#DFTK.G_to_r!"><code>DFTK.G_to_r!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">G_to_r!(f_real, pw::PlaneWaveBasis, [kpt::Kpoint, ], f_fourier)</code></pre><p>Perform an iFFT to translate between <code>f_fourier</code>, a fourier representation of a function either on <span>$B_k$</span> (if <code>kpt</code> is given) or on <span>$C_ρ$</span> (if not), and <code>f_real</code>. The function will destroy all data in <code>f_real</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/ca41d97753148d8d973f5a8b6617d76c558ba742/src/core/PlaneWaveBasis.jl#L213-L219">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.r_to_G!" href="#DFTK.r_to_G!"><code>DFTK.r_to_G!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">r_to_G!(f_fourier, pw::PlaneWaveBasis, [kpt::Kpoint, ], f_real)</code></pre><p>Perform an FFT to translate between <code>f_real</code>, a function represented on <span>$C_ρ^\ast$</span> and its fourier representation. Truncatate the fourier coefficients to <span>$B_k$</span> (if <code>kpt</code> is given). Note: If <code>kpt</code> is given, all data in <span>$f_real$</span> will be distroyed as well.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/ca41d97753148d8d973f5a8b6617d76c558ba742/src/core/PlaneWaveBasis.jl#L265-L272">source</a></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>PotLocal</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>PotNonLocal</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>Kinetic</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.Hamiltonian" href="#DFTK.Hamiltonian"><code>DFTK.Hamiltonian</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Initialise a one-particle Hamiltonian from a model and optionally a density.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/ca41d97753148d8d973f5a8b6617d76c558ba742/src/core/Hamiltonian.jl#L21-L23">source</a></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>apply_hamiltonian!</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>DFTK.apply_fourier!</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>DFTK.apply_real!</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>DFTK.update_potential!</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>DFTK.update_energies_potential!</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>DFTK.empty_potential</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.PreconditionerKinetic" href="#DFTK.PreconditionerKinetic"><code>DFTK.PreconditionerKinetic</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Kinetic-energy based preconditioner.</p><p>Applies <span>$1 / (|k + G|^2 / 2 + α)$</span> to the vectors, when called with <code>ldiv!</code>. This attempts to dampen the high-kinetic energy parts of the Hamiltonian, thus making the Hamiltonian more well-conditioned.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/ca41d97753148d8d973f5a8b6617d76c558ba742/src/core/Preconditioner.jl#L9-L15">source</a></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>DFTK.lobpcg</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>DFTK.lobpcg_qr</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.lobpcg_scipy" href="#DFTK.lobpcg_scipy"><code>DFTK.lobpcg_scipy</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">lobpcg_scipy(A, X0; prec=nothing, tol=nothing, largest=false, kwargs...)</code></pre><p>Call scipy&#39;s version of LOBPCG for finding the eigenpairs of a Hermitian matrix <code>A</code>. <code>X0</code> is the set of guess vectors, also determining the number of eigenpairs to be sought.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/ca41d97753148d8d973f5a8b6617d76c558ba742/src/core/diag_lobpcg_scipy.jl#L3-L8">source</a></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>DFTK.lobpcg_itsolve</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>DFTK.occupation_zero_temperature</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>self_consistent_field</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>DFTK.scf_nlsolve</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>DFTK.scf_damped</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.PspHgh" href="#DFTK.PspHgh"><code>DFTK.PspHgh</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">PspHgh(Zion::Number, rloc::Number, cloc::Vector, rp::Vector, h::Vector;
       identifier=&quot;&quot;, description=&quot;&quot;)</code></pre><p>Construct a Hartwigsen, Goedecker, Teter, Hutter separable dual-space Gaussian pseudopotential (1998). The required parameters are the ionic charge <code>Zion</code> (total charge - valence electrons), the range for the local Gaussian charge distribution <code>rloc</code>, the coefficients for the local part <code>cloc</code>, the projector radius <code>rp</code> (one per AM channel) and the non-local coupling coefficients between the projectors <code>h</code> (one matrix per AM channel).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/ca41d97753148d8d973f5a8b6617d76c558ba742/src/core/PspHgh.jl#L15-L25">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.eval_psp_projection_radial" href="#DFTK.eval_psp_projection_radial"><code>DFTK.eval_psp_projection_radial</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">eval_psp_projection_radial(psp::PspHgh, i, l, qsq::Number)</code></pre><p>Evaluate the radial part of the <code>i</code>-th projector for angular momentum <code>l</code> at the reciprocal lattice point with modulus squared <code>qsq</code>.</p><p>p(qsq) = ∫<em>{R+} r^2 p(r) j</em>l(q r) dr</p><p><a href="7-15">HGH98</a> except they do it with plane waves normalized by 1/sqrt(Ω).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/ca41d97753148d8d973f5a8b6617d76c558ba742/src/core/PspHgh.jl#L143-L152">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.eval_psp_local_real" href="#DFTK.eval_psp_local_real"><code>DFTK.eval_psp_local_real</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">eval_psp_local_real(psp, r)</code></pre><p>Evaluate the local part of the pseudopotential in real space. The vector <code>r</code> should be given in cartesian coordinates.</p><p><a href="1">GTH98</a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/ca41d97753148d8d973f5a8b6617d76c558ba742/src/core/PspHgh.jl#L124-L131">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.eval_psp_local_fourier" href="#DFTK.eval_psp_local_fourier"><code>DFTK.eval_psp_local_fourier</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">eval_psp_local_fourier(psp, ΔG)</code></pre><p>Evaluate the local part of the pseudopotential in reciprocal space.</p><p>This function computes V(q) = ∫<em>R^3 Vloc(r) e^{-iqr} dr      = 4π ∫</em>{R+} sin(qr)/q r e^{-iqr} dr</p><p><a href="6">GTH98</a> except they do it with plane waves normalized by 1/sqrt(Ω).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/ca41d97753148d8d973f5a8b6617d76c558ba742/src/core/PspHgh.jl#L96-L106">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.compute_density" href="#DFTK.compute_density"><code>DFTK.compute_density</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">compute_density(pw::PlaneWaveBasis, Psi::AbstractVector, occupation::AbstractVector)</code></pre><p>Compute the density for a wave function <code>Psi</code> discretised on the plane-wave grid <code>pw</code>, where the individual k-Points are occupied according to <code>occupation</code>. <code>Psi</code> should be one coefficient matrix per k-Point.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/ca41d97753148d8d973f5a8b6617d76c558ba742/src/core/compute_density.jl#L42-L48">source</a></section><h2><a class="nav-anchor" id="Utilities-1" href="#Utilities-1">Utilities</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.Species" href="#DFTK.Species"><code>DFTK.Species</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Species(Znuc; psp=nothing)</code></pre><p>Structure collecting information about a species in a structure or crystal.</p><ul><li><code>Znuc</code>: Nuclear charge (single atom) or accumulated nuclear change (composition)</li><li><code>psp</code>:  Pseudopotential to be used (or nothing for all-electron treatment)</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/ca41d97753148d8d973f5a8b6617d76c558ba742/src/core/Species.jl#L6-L12">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.determine_grid_size" href="#DFTK.determine_grid_size"><code>DFTK.determine_grid_size</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">determine_grid_size(lattice, Ecut; supersampling=2)</code></pre><p>Determine the minimal grid size for the fourier grid <span>$C_ρ$</span> subject to the kinetic energy cutoff <code>Ecut</code> for the wave function and a density  <code>supersampling</code> factor. Optimise the grid afterwards for the FFT procedure by ensuring factorisation into small primes. The function will determine the smallest cube <span>$C_ρ$</span> containing the basis <span>$B_ρ$</span>, i.e. the wave vectors <span>$|G|^2/2 \leq E_\text{cut} ⋅ \text{supersampling}^2$</span>. For an exact representation of the density resulting from wave functions represented in the basis <span>$B_k = \{G : |G + k|^2/2 \leq E_\text{cut}\}$</span>, <code>supersampling</code> should be at least <code>2</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/ca41d97753148d8d973f5a8b6617d76c558ba742/src/core/PlaneWaveBasis.jl#L37-L49">source</a></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>build_local_potential</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>build_nonlocal_projectors</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>kblock_as_matrix</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.load_psp" href="#DFTK.load_psp"><code>DFTK.load_psp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">load_psp(identifier; datadir_psp)</code></pre><p>Load a pseudopotential file from the library of pseudopotentials. The file is searched in the directory <code>datadir_psp</code> and by the <code>identifier</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/ca41d97753148d8d973f5a8b6617d76c558ba742/src/utils/load_psp.jl#L11-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DFTK.guess_density" href="#DFTK.guess_density"><code>DFTK.guess_density</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">guess_density(basis, composition...)</code></pre><p>Build a superposition of atomic densities (SAD) guess density. The atoms/species are specified in <code>composition</code> as pairs representing a mapping from <code>Species</code> objects to a list of positions in fractional coordinates.</p><p>We take for the guess density a gaussian centered around the atom, of length specified by <code>atom_decay_length</code>, normalized to get the right number of electrons</p><div>\[\hat{ρ}(G) = Z \exp\left(-(2π \text{length} |G|)^2\right)\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMolSim/DFTK.jl/blob/ca41d97753148d8d973f5a8b6617d76c558ba742/src/utils/guess_density.jl#L1-L13">source</a></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>guess_hcore</code>. Check Documenter&#39;s build log for details.</p></div></div><h2><a class="nav-anchor" id="Definition-of-builder-functions-1" href="#Definition-of-builder-functions-1">Definition of builder functions</a></h2><pre><code class="language-none">Definition of builder functions
   builder(basis::PlaneWaveBasis, energy::Ref, potential; ρ=nothing, Ψ=nothing, kwargs...)
       energy       nothing or reference
       potential    nothing or Array or data structure

   energy !== nothing
       Reference updates with new energy value
   potential !== nothing
       Potential array update with new potential values
       or data structure to use for updating potential data
   energy !== nothing and potential !== nothing
       compute potential values and energies and return energy, potential
       May reuse the storage of the `potential` object

Note: - It is *not* required nor guaranteed that the returned `potential` is an array.
        E.g. for the non-local pseudopotential term it will be a PotNonLocal datastructure.
        The returned energy value, however, is always a scalar.
      - The arguments `ρ` or `Ψ` are not required for calling the function, but the
        function might throw if they are for the requested computations.</code></pre><p>Because we do not explicitly make sure the Fourier representation of an analytic potential is a real fucntion in real space only the real part of the real-space representation of a potential is physically meaningful.</p><footer><hr/></footer></article></body></html>
